<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Tools are the bane of the Beginner</title>
        <meta name="viewport" content="width=device-width, initial-scale=0.8"/>

        <link rel="stylesheet" media="all" type="text/css" href="/css/stacklayout.css" />
        <!--[if lte IE 7]>
        <link rel="stylesheet" media="all" type="text/css" href="css/stacklayout_lte_ie7.css" />
        <![endif]-->

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/vinodkd.org.css">    
    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/"></a></h1>
            </div>
     
                <p class="meta">27 Jun 2012</p>

<div id="post" class="node">
<h1>Tools are the bane of the Beginner</h1>
<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><div style="text-align: justify;"></div><div style="text-align: justify;">"Huh? Isn't that counter-intuitive?", you ask?<br />I realizing something particular as a result of some experiences and wrote that line down, but to me even it sounds counter-intuitive; so let me hasten to explain.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A beginner, for the purposes of this discussion, is somebody who's beginning something. This could be a novice starting to learn a skill; but it could also be an expert who's beginning a new project within his area of expertise.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A a beginner (thus defined) is hindered by the presence of tools and frameworks for two reasons:&nbsp;</div><ul style="text-align: left;"><li style="text-align: justify;">They obscure the what and the how of the problem at hand by hiding it within ( usually for novice beginners).</li><li style="text-align: justify;">They prevent easy exploration of the why of the problem and its solution space through ceremony and preventing access(usually for experienced beginners).</li></ul>Allow me to present the experiences that led to this realization. It all began one mundane work day in the not-too-distant past....<br /><h3 style="text-align: justify;"><br /></h3><h3 style="text-align: justify;">    Story#1</h3><div style="text-align: justify;">My team had just got a bunch of freshers. They were recent engineering graduates (presumably with some exposure to programming) who have passed through the company's training program (which again presumably imparts further such exposure). We, however, found that they couldn't do some simple tasks like write code outside Eclipse. They didn't know how to deploy a web application except through the Eclipse plugin; had never debugged an application via logs and in fact didn't know &nbsp;about webapps as an idea independent from "Tomcat". Their OO concepts were shaky at best, but they had implemented small-but-complete web applications using Tomcat, Struts and Hibernate and passed an EJB exam. When asked to build their study app the same from scratch using a command line, however, they were lost. When asked to build a different application (than the one they'd done) *using Eclipse*, they were similarly lost.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">While a large portion of the blame should rightly lie in the teaching methodology (or lack of one), the tools and frameworks too, IMO, should bear some of it. "Deploying" for them meant clicking on the Tomcat icon in Eclipse, so they had no use of knowing what "web.xml" did nor did they know that it was no longer required. The same wizards and menu options that make the life of a practitioner easy actually obscure the underlying process (and why its required) to a beginner.</div><h3 style="text-align: left;"><br /></h3><h3 style="text-align: left;">    Story#2</h3><div style="text-align: justify;">The same group of freshers were slowly getting on track with (re)learning the basics of programming, when I thought it might be a good idea to instill in them at this "early age" the values of Test Driven Development. I immediately checked myself, however, because they'd have to learn JUnit and how to use it. On second thoughts, however, I realized that they didn't HAVE to use Junit or any such framework to do TDD. All they had to do was write a test before writing the actual code, have it fail, write the code and have it pass the test. The test could be code in the same function or in main() or as a series of calls to the program stored as a shell script or as JUnits. All of them are equally valid as "tests". We generally, however, recognize only the last of these as tests. The concept of TDD has been usurped by the concepts of the tools that implement it - to the extent that TDD doesn't seem have a life outside of those tools.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Tools, therefore, seem to be actively scuttling the consumption and adoption of Concepts, even when they were created explicitly for the reason of automating the repeated application of known concepts.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">I personally have been struggling with this - the guilt of not doing TDD vs the allure of just seeing working code - especially when I'm beginning something and still feeling the problem and solution spaces out. In some cases, the solution space doesnt have readily available tools (BDD on the browser, anyone?) and in others there are tools but I'm still not ready to commit to them because I dont know what my solution is yet (should I build the parser first to figure out the syntax or the AST interpreter to see how it would run?). My liberation came when I declared that a test will be whatever I call a test for the situation at hand, not what some framework determines to be one. Since then the test-red-code-green-repeat cycle is a much more doable one.</div><div style="text-align: justify;"><br /></div><h3 style="text-align: left;">    Full Circle</h3><div style="text-align: justify;">Back to the initial "Huh?" moment from the beginning. Why then do we generally consider tools to be useful - especially for beginners? Tools are generally time-savers. They do one thing and they do it well; and that is their value. They do, however, have an "operating range" in which they're most useful. Below that, they're overkill and above, they're obstructive - as depicted in this highly accurate graph on problem size vs tool effectiveness:</div><div style="text-align: justify;"><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-H61P5wwnJQ0/T-rkOvp4vXI/AAAAAAAAAC8/_YtMWdcYgJg/s1600/tool.vs.problem.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="208" src="http://4.bp.blogspot.com/-H61P5wwnJQ0/T-rkOvp4vXI/AAAAAAAAAC8/_YtMWdcYgJg/s400/tool.vs.problem.png" width="400" /></a></div><br /><br />So when we usually talk about tools being useful, we're talking about the useful operating range. Specifically for beginners, tools are solution accelerators at that range. The stories presented here represent the two ends of the spectrum, however, where tools are sub-optimal.<br /><div><br /></div></div><div style="text-align: justify;"><b>Note</b>:&nbsp;I've glossed over frameworks in this discussion, but the concept is the same; or applicable even more so for frameworks. Frameworks by definition are a standard solution to a common problem, with room for customization so that application specifics can still be implemented. The framework is one because it has a known world view and exposes an interface that allows operations on that world view. The concept of operating range is well-ingrained, therefore; as are those of the limits on either side.So please read "tools/frameworks" wherever you see "tools" below.<br /><div><br /></div></div><h3 style="text-align: justify;">      So...</h3><div style="text-align: justify;">Armed with this framework for evaluating tools, we can start asking some interesting questions.</div><div style="text-align: justify;"></div><ol><li style="text-align: justify;">What is a good tool?</li><li style="text-align: justify;">When are tools not required?</li><li style="text-align: justify;">When are tools required?</li><li style="text-align: justify;">How do we determine the operating range of a tool, then?&nbsp;</li><li style="text-align: justify;">What can we do to use tools more effectively?</li><li style="text-align: justify;">What can tool builders do to make effective tools</li></ol><div style="text-align: justify;">Attempts at answers to these questions in part 2 of this article.</div></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>

<div>tags: rant, soapbox </div>
</div>


            <div id="footer" class="stackContent">
              <div class="stackAuto item"><span class="stackContent">&copy; 2022 Vinod KD </span></div>
              <div class="stackAuto item">
                <a class="stackContent" href="http://github.com/vinodkd">github/vinodkd</a>
              </div>
              <div class="stackAuto item">
                <a class="stackContent" href="http://twitter.com/vinod_dinakaran">@vinod_dinakaran</a>
              </div>
            </div>
            </div>
        </div> <!-- /container -->

    </body>
</html>
