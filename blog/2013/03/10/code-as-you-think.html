<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Code as you think</title>
        <meta name="viewport" content="width=device-width, initial-scale=0.8"/>

        <link rel="stylesheet" media="all" type="text/css" href="/css/normalize.css" />
        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">
        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">    
    </head>
    <body class="container">
      <header class="is-left stck-horizontal">
        <h1><a href="/"><img src="/favicon.png"></a>  Code as you think</h1>
      </header>
      <article>
        <div id="post" class="post">
    <header class="post-header">
        <span class="post-title">Code as you think - ( 10 Mar 2013 )</span>
        
            <span class="post-tag">ideas </span>
        
            <span class="post-tag">ideas-wip </span>
        
    </header>
    <article class='post-content'>
        <div dir="ltr" style="text-align: left;" trbidi="on"><span style="text-align: justify;">I was in the middle of deciding how to proceed with my current side project when I realized that I'd not yet created an architectural description for it. Since I already have an <a href="https://github.com/vinodkd/sid">architecture description tool </a></span><b style="text-align: justify;"><a href="https://github.com/vinodkd/sid">that I wrote</a></b><span style="text-align: justify;">, I have no excuse for not writing one out. So I stopped to think why I didn't create an architecture definition first. Ans: Because it would stop me from doing what I was doing right then, which was to decide:</span><br /><br /><ul style="text-align: left;"><li style="text-align: justify;">how to separate out the current spike of the language from its sample code and actions.</li><li style="text-align: justify;">how this will be deployed in and of itself, ie how to dogfood it?</li><li style="text-align: justify;">how to move from the spike folder to the actual folder</li><li style="text-align: justify;">how to move from bitbucket(where I'm keeping all this stuff till its public-worthy) to github or a public bitbucket repo (where I expect this to be shared with the world)</li><li style="text-align: justify;">...all in the middle of adding commit messages for changes</li><li style="text-align: justify;">while juggling code between the PC and the mac</li><li style="text-align: justify;">... and so on.</li></ul><br /><div style="text-align: justify;">As I'm writing this, more thoughts are streaming through, and they're all jumbled together: code ideas, architecture ideas, documentation, behind-the-scenes reasons, journal entries - all in one single stream of consciousness. Stopping now to create an architecture definition would not just slow me down, it would take me down a totally different path. And I don't want to go down that path because the IDEAS ARE JUST FLOWING!<br /><br />Another reason I didn't want to context switch into "architecture definition mode" was the high cost of that switch : create a new document, decide where to save it, type in the actual content, optionally see how it looks once the markdown becomes html and so forth. IMO, this is also why documentation is out-of-date with code, especially expository documentation like architecture and design docs. The comment-above-code kind of documentation may still be in touch with the reality of the code, but higher level documentation like READMEs and user guides quickly become disconnected from the code they're talking about.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">That's when it hit me: What we need are tools and languages that understand the stream-of-consiousness way of building software: code snippets flying into the system from the human mind along with documentation and random thoughts and todos and reorganizations of such thoughts - all of which the system will record in sequence and generate meaningful views out of.&nbsp;</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Imagine an editor that:</div><ul style="text-align: left;"><li style="text-align: justify;">Allows creation of content without the need to pick a name or a location for it.</li><li style="text-align: justify;">Knows enough about the content to provide appropriate editing affordances - syntax highlighting, preview, whatever.</li><li style="text-align: justify;">... and autosaves it for you - no separate save step required</li><li style="text-align: justify;">... then allows tagging it as being "of a particular type"... whatever that means to you</li><li style="text-align: justify;">... then allows you to seamlessly retag it differently</li><li style="text-align: justify;">... including being able to arrange it in hierarchies (if that made sense) or graphs (ie nodes and links - if that made better sense)</li><li style="text-align: justify;">Presents all existing content and its associated "tag graph"</li><li style="text-align: justify;">Allows linking content with each other</li><li style="text-align: justify;">... or even parts of content with each other.</li><li style="text-align: justify;">Shows the links visibly</li><li style="text-align: justify;">Allows tagging parts of a document as being of a different tag, but still housed in the source document. Content tagged thus will be displayed in both tagged content, but the second display will be a reference to the original.</li><li style="text-align: justify;">Tracks all changes to the content graph in a stream-of-consciousness journal that's visible and accessible at all times so that you can see what you did before <b>in the order that you did it.</b></li><li style="text-align: justify;">Allows you to add your own manual entries to the journal to track your thoughts at that point in time.</li></ul><div style="text-align: justify;">Such an editor could be used to make the context switches mentioned above as seamless as possible. The only bit of automation it promises is the decidedly "big brother"-like journal, but in my opinion that's something the computer <b>should</b> do for us - track what we're doing automatically so we can look back and "see the trace of our thoughts from before in our actions". Features like seamless switching allows easy creation of design, code, comments&nbsp;&nbsp;and code in back-n-forth style, for example; while the ability to link content allows for todos to be linked to the point in code where change is required, but still can be maintained as a separate list of todos for easy review.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">To allow easy adoption, such an editor should add the following:</div><ul style="text-align: left;"><li>Treat an existing directory structure as the basis for its tags: folders become tags, folder structures become hierarchical tags, files become fully described hierarchical tags. If starting from a blank folder, however, allow for the initial tagged content to remain as files until the user discovers the "natural order of things" for himself.</li><li>Seamlessly convert files to folders when the user renames them.</li><li>Save the changes to the underlying folder as soon as possible so that there's no "last minute unsaved content change"</li><li>Allow for some scripting/automation triggered by content changes.</li></ul><div><u>UI Design Notes:</u></div><ul style="text-align: left;"><li style="text-align: justify;">Start the editor from a particular dir, which we'll call <dir> in these notes. The startup sequence allows choosing the default language to use optionally, else the default is text.</li><li style="text-align: justify;">The editor starts with two windows: a default one titled "<dir>" and the journal titled "stream". The former is editable, the latter is read-only.&nbsp;</li><li style="text-align: justify;">The default window&nbsp;is "in" the default language (if chosen), ie is syntax highlighted for that language. Typing text into it and hitting enter causes text to show up like any editor, but it also causes the same text to show up in the stream window with a date/time stamp. Internally, the text in the stream window is a reference to the line in the original window, not a copy of its contents. In the background, all the text changes are saved back to <dir>.</li><li style="text-align: justify;">Typing F2 allows you to rename the window's title, which is also its tag. The editor allows creation of hierarchical tags like "tag1/tag2/tag3". It also allows setting the language of the content by naming the tag with the format "tag.type" - similar to how files are named today.</li><li style="text-align: justify;">Typing an esc puts you into "enter a tag" mode. a small edit area (or vim/emacs-style command area) shows up which allows you to type in the name of a tag such as "todo" or "comment" or whatever. hit enter when done and two things happen: the edit area disappears and a new window titled with the tag just entered shows up and focus moves to that window. Type text and hit enter to enter content in this mode, while it also appears the stream window like before. if the tag is already present, focus shifts to the existing window for that tag and text input proceeds from there.</li><li style="text-align: justify;">Selecting text and then pressing esc to select a tag will leave the text in the original window, but add that text to the window corresponding to the chosen tag (via reference again), as well as denote that the tagging event occured in the stream window. Presssing ctrl-esc instead of esc will cause the text to be moved to the tag chosen.</li><li style="text-align: justify;">Ctrl-tab will cycle through all open windows and allow you to make any window the main one. The same esc and enter behavior holds for all windows.</li><li style="text-align: justify;">Everything is save-as-you-type. No ctrl-s required. The tag is the name of the content.</li></ul><div style="text-align: justify;">More features:</div><div style="text-align: justify;"></div><ul><li>Windows are tiled, not free. this allows pinning of windows to specific locations so as to create familiar screen layouts.</li><li>A third kind of window is a modal window, which can be in input or output mode. this will allow creation of repls. issue a command when its in input mode and view results when its in output mode, which is read-only. The "stream" window can also be recast as a modal window, allowing journal entries in input mode.</li></ul><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ok, that was the easy part. What about a s-o-c language?</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Such a language would:<br /><br /><ul><li>Allow for programs to be expressed one chunk at a time. The language runtime could be invoked at any time during the expression, at which event the runtime would evaluate the current set of chunks and determine if it can do anything with it. If the runtime is a compiler, it would decide if object code can be generated or not; and if its an interpreter, it would interpret the chunks available.</li><li>Not have comments. Instead it would allow a more generic interpretation of commented content as "chunks from another language embedded within itself, which could be "understood" or "translated to itself" given an appropriate cross-interpreter/compiler.</li><li>Allow chunks to be linked to each other and handle link lifecycle events. Eg: chunk A is related to chunk B could imply that if A changes, B should also change; thus flag such changes on A as requiring changes in B as well. Or, if chunk A is deleted, chunk B should be deleted as well because it doesnt make sense to keep it around anymore. Or, if chunk A is created, a corresponding chunk B MUST be created.</li></ul></div><div style="text-align: justify;">More thoughts on the language TBD.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b><u>Implementation Notes</u></b></div><div style="text-align: justify;">Editor:</div><div style="text-align: justify;"></div><ul><li>Use node-webkit, codemirror and sharejs to allow evented entry of text</li><li>Make a repl using a bot that's sitting at the other end of a sharejs connection.</li></ul><div><b><u>WIP notes</u></b></div><div><br /></div><div>Started work on a prototype using node-webkit. A basic version of the UI Design has been implemented, and the updated version of this post reflects some experiences from this implementation.</div></div>

    </article>
</div>

      </article>
      <small class="is-right">&copy; 2023 Vinod KD </small>
    </body>
</html>
