<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Groovy DSL Voodoo... or why I think imperative programming makes more evolutionary sense</title>
        <meta name="viewport" content="width=device-width, initial-scale=0.8"/>

        <link rel="stylesheet" media="all" type="text/css" href="/css/normalize.css" />
        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">
        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">    
    </head>
    <body class="container">
      <header class="is-left stck-horizontal">
        <h1><a href="/"><img src="/favicon.png"></a>  Groovy DSL Voodoo... or why I think imperative programming makes more evolutionary sense</h1>
      </header>
      <article>
        <div id="post" class="post">
    <header class="post-header">
        <span class="post-title">Groovy DSL Voodoo... or why I think imperative programming makes more evolutionary sense - ( 01 Mar 2013 )</span>
        
            <span class="post-tag">dsl </span>
        
            <span class="post-tag">rant </span>
        
            <span class="post-tag">groovy </span>
        
            <span class="post-tag">fluent </span>
        
            <span class="post-tag">jack </span>
        
    </header>
    <article class='post-content'>
        <div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div style="text-align: justify;">I recently had to consider the Groovy space for a project proposal as the client had decided on Groovy/Grails as the platform of choice. While evaluating the platform for the proposal, I naturally gravitated towards Groovy's DSL capabilities and started thinking about using it for my personal projects, obviously. Abu seems like a natural fit (why didnt I think of Groovy before, I wonder? I'd hit a wall with JRuby due to generics anyway); as did Jack.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Anyhoo, with all this background, I hit slideshare and found tons of decks from the language leads on the specific topic of DSLs. One example piqued my interest in particular: slide 106 of <a href="http://www.slideshare.net/paulk_asert/groovydsls#btnNext">Paul King's deck</a>, which I've&nbsp;replicated here as a gist:</div><div style="text-align: justify;"><br /></div></div><div style="text-align: justify;"><script src="https://gist.github.com/vinodkd/5062824.js"></script><br /></div><div style="text-align: justify;">I wanted to both understand how this worked and to replicate it by myself. Here's all the flailing I went about in trying to achieve those two goals:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><script src="https://gist.github.com/vinodkd/5062839.js"></script> As you can see, I failed miserably. My last trial had a near-working version, but left me completely disillusioned about Groovy's DSL capabilities - especially considering I came out of the process feeling that all the work was done by the single 'of' closure with the rest playing dummies to the Groovy language's optional syntax rules - especially because in my Englishy version, you could switch the order of the closures passed into 'of' and still have it work fine.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">However, all of this didn't explain the "extra code" in the original, which left me with the nagging feeling that no language author would be trying to pull this much wool over people's eyes. So I went back and expanded the original expressions like so: <script src="https://gist.github.com/vinodkd/5062875.js"></script></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Now it made much better sense.<br /><br />Mind you, I still haven't figured out how you go from a problem statement like "I want to express the ability to compute square roots in an English-y fashion" to the solution presented above. This is as far as I can get:</div><div style="text-align: justify;"></div><ol><li>I'll obviously need a way to call Math.sqrt and then print it. This needs to be a function name that's english-y</li><li>An englishy description could be something like "Show the square root of 100". Using Groovy's existing rules, that makes "of" the candidate for the function name.</li><li>How now do we make the rest of the words work? Well, "show" and "square root" are exactly the two actions to be taken. So as long as I can define those as functions and compose them, I'm good.</li><li>How do I pass in the functions without naming them?</li></ol><div><div style="text-align: justify;">Obviously, its all the baggage of years of imperative programming knowledge holding me back. Somebody with more skill in functional programming might find this the intuitive enough to roll out.</div></div><div><div style="text-align: justify;"><br /></div></div><div><div style="text-align: justify;">But I have to wonder: <b>There's too much magic going on here</b>. The imperative approach to the stated requirement would be to define a grammar, write a parser and allow actual interpretation of such a language. Painstaking and error prone, sure; but explicit and clearly out of the programmer's head and into a language that is so dumb that there's no doubt as to what's happening.</div></div><div><div style="text-align: justify;"><b><br /></b></div></div><div><div style="text-align: justify;">This sounds like I'm propounding Worse Is Better in other words, &nbsp;but there's something more: I realized that the cognitive overload required to understand the Groovy version is higher. More importantly, the cognitive overload to retain that understanding over time is even more so - for "normal" developers who have not walked the functional way for very long. That's the majority in today's world, at least.</div></div><div><div style="text-align: justify;"><br /></div></div><div><div style="text-align: justify;"><b>More insidious</b>, however, <b>is the implied promise that this is real</b>; that the Groovy DSL is actually English. Could I, for example, expect the slightly less polite "show the square_root of 100" to work? Or the even curt "square_root of 100"? &nbsp;As an English speaker, why would I not?<br /><br />As a programmer, I see why 'please' and 'the' are the required glue to make the english-y sentence work within Groovy's pretend-English world. Its extensible in that you could replace square_root with cube_root, for example; but not so that you could change the grammar of the sentence itself. That would require a different set of closures, like the ones you'd find in slide 105 of the same deck, for example. Note that in this version its 'the()' that is the active closure. But I fail to see why this should prevent me from expressing myself naturally as an English speaker.</div></div><div><div style="text-align: justify;"><br /></div></div><div><div style="text-align: justify;">This then, IMO, is the larger problem with DSLs. When you make something like its real-world counterpart, the human mind immediately taps into the huge body of latent real-world knowledge and tries to use it with that thing: although this DSL doesnt promise it, I immediately wanted to use English structure on it. It's all fine that your programming language has risen to talk your user's language, but has it captured enough of the user's world to go beyond "training wheel use"? To <a href="http://en.wikiquote.org/wiki/Carl_Sagan">paraphrase Carl Sagan</a>,: <b>To make an apple pie DSL, you must make a universe that's up to scratch</b>.&nbsp;</div></div><div><div style="text-align: justify;"><br /></div></div><div><div style="text-align: justify;">How will the DSL author handle this? In general, not very well, I think. I realize I'm picking on a toy example here, but on extrapolation I cannot imagine a domain where all possible concepts and all of their possible combinations are easily enumerated; and then retain their meaning over time and across minds.</div></div><div><div style="text-align: justify;"><br /></div></div><div><div style="text-align: justify;">I begin to wonder then, at attempts like the VPRI's FONC, where one of the overarching ideas seems to be to create a multitude of DSLs to produce an OS in under ~20 KLOC; and at feeble attempts like my vaporware designs of Jack and Fluent: would they build a better world or is the imperative code bloat of Windows and Linux the more sustainable way?<br /><br /></div></div></div>

    </article>
</div>

      </article>
      <small class="is-right">&copy; 2023 Vinod KD </small>
    </body>
</html>
