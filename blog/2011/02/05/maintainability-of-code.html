<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Maintainability of code</title>
        <meta name="viewport" content="width=device-width, initial-scale=0.8"/>

        <link rel="stylesheet" media="all" type="text/css" href="/css/stacklayout.css" />
        <!--[if lte IE 7]>
        <link rel="stylesheet" media="all" type="text/css" href="css/stacklayout_lte_ie7.css" />
        <![endif]-->

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/vinodkd.org.css">    
    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/"></a></h1>
            </div>
     
                <div id="post" class="post">
    <div class="post-header">
        <span class="post-title">Maintainability of code - ( 05 Feb 2011 )</span>
        
            <span class="post-tag">rant </span>
        
    </div>
    <div class='post-content'>
        <div dir="ltr" style="text-align: left;" trbidi="on">Most of my career has involved maintaining code built by others. I'd wager that most developers' career has been the same, even if they didn't want to admit it. Sometimes maintenance goes under the name of updating your own code, so people delude themselves into thinking they're not maintaining code, they're just creating the next version. From a maintainability POV, any code that's built is legacy.<br /><br />And yet most (all?) methodologies of software development either address completely start-from-scratch greenfield development, or propose ideal practices that mature, passionate developers who are in the field for the love of programming.<br /><br />The reality, however, is that most development involves enhancing or maintaining&nbsp;code - usually&nbsp;somebody else's, and mostly crufty; and in all likelihood the crufty code is from somebody who's presence in the industry is a happenstance rather than a planned event. If you're lucky it merely represents somebody's state of maturity at the time of writing, and that person has now improved.<br /><br />A comprehensive methodology for maintainable software, therefore, must:<br /><ul style="text-align: left;"><li>To address the legacy code angle:</li><ul><li>Provide mechanisms to create "good enough" comprehension of the code</li><ul><li>But avoid attempts at large scale or totalitarian model-driven comprehension. Such attempts will always fail in the real world simply because there will always be something outside the model</li><li>That is, allow for leaky abstractions</li><li>That is, allow for manual steps. There will always be manual steps. The methodology should allow for that by exclusion or explicit statement.The former is easier.</li></ul><li>Help identify what changes and what doesn't. Easier: help identify what has changed and not in the past and let the humans extrapolate to the future.</li><li>Provide a means to migrate from what is to what should be that's incremental.</li></ul><li>To address the maturity concern:</li><ul><li>Allow for different levels of maturity</li><li>Allow for the ability to define "good enough" architecture, design and code; and the ability to easily enforce it</li><li>Allow quick enough comprehension of these definitions</li><li>Allow for gradual adoption, and a means to measure progress</li></ul></ul><div>The usual solution is to relegate this to Software Engineering, which typically spirals into talks of CMM and suchlike - process heavy, people agnostic.</div><div><br /></div><div>The reality, however, is that software development is largely a human effort, and precisely because it lacks the usual shackles of other human endeavors. A mechanical, electrical or electronics engineer will always hit upon some natural limit. Not so the software engineer. His limits are the limits of the mind. If you can think it, you can make it.</div><div><br /></div><div>And therein lies the problem. If you can think it, so can a multitude of other software engineers; and each such mind can think of at least one variation to the same problem using the same essential solution. This is why I believe we will not see Software ICs any time soon. Most process oriented methodologies tend to gravitate towards this concept, or to the equivalent one of "resources tasked to do X will repeatably produce output of increasing metric Y".</div><div><br /></div><div>Meantime, in the real world, human programmers are finding ways to game that system.&nbsp;</div><div><br /></div><div>As software practitioners, what are we doing to better this? There seem to be promising starts with the BDD and (to a smaller extent) TDD movements, and (in a less focused, but generic scale) with the general move towards declarative programming. There're some incremental gains from tooling in general, but those gains are largely in the area of reducing the steps that the interface requires you to go through to achieve any particular task. There's also some progress in architecture analysis, validation and enforcing that constructs such as <a href="http://www.dsmweb.org/">DSM</a> and its ilk provide - if practiced regularly.</div><div><br /></div><div>However, all of these lean toward the mature, self-aware programmer. By the time it reaches Joe Developer, its an organization mandate, not something he WANTS to do. So the gaming cycle begins. This time, however, its insidious because it projects the impression that code quality has improved. We therefore need tools and methods that "work in the trenches". I don't have a good enough answer, but here're are some interim steps that I can think of:</div><div><ul style="text-align: left;"><li>Allow for easy documentation of what exists, and in such a way that the document follows changes. Working diagrams are a good way of documenting the subset of the code that's understood.&nbsp;</li><li>Use tagging as a means of collation of documentation created thus. Its easy and "good enough".</li><li>Don't loose what you gain. Developers gain a lot of system knowledge during debugging. There's no easy way of saving that for posterity, so the knowledge is lost. Do not expect developers to write a wiki page - they don't have the time. This area is ripe for tools such as&nbsp;</li><ul><li>bookmarking and code traversal trails being saved.&nbsp;</li><li>A "tweet my XApp-fu" app is what's required here.</li><li>A way to share all of this that's searchable</li></ul><li>Make creating tests a 1-click affair. Any run of the software should be convertible into a test, especially a manual &nbsp;during the normal write-compile-test cycle that the developer engages in.</li><li>Allow cheating on setting up the context. In most production systems, its not easy to inject mocks or test doubles. Test automation should allow for as little of the system being mocked out as possible.</li><li>Mindset changes:Somebody on the team needs to evangelize these:</li><ul><li>"Works on integration box" is less useful than "PROVABLY works on any box". This implies CI without requiring buying into the CI religion.</li><li>Exemplar test data is better than just test data. Exemplars are test data sets that "stand for" a scenario, not a particular test run.&nbsp;</li></ul></ul></div></div>

    </div>
</div>


            <div id="footer" class="stackContent">
              <div class="stackAuto item"><span class="stackContent">&copy; 2022 Vinod KD </span></div>
              <div class="stackAuto item">
                <a class="stackContent" href="http://github.com/vinodkd">github/vinodkd</a>
              </div>
              <div class="stackAuto item">
                <a class="stackContent" href="http://twitter.com/vinod_dinakaran">@vinod_dinakaran</a>
              </div>
            </div>
            </div>
        </div> <!-- /container -->

    </body>
</html>
