<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Painting vs Rendering</title>
        <meta name="viewport" content="width=device-width, initial-scale=0.8"/>

        <link rel="stylesheet" media="all" type="text/css" href="/css/normalize.css" />
        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">
        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">    
    </head>
    <body class="container">
      <header class="stack-horizontal">
        <a href="/"><img id="LOGO" src="/favicon.png"></a>  
        <div class="stack-vertical">
            <h2>Painting vs Rendering</h2>
            <div class=""stack-horizontal>
                <span>24 Sep 2011 </span>
                
            </div>
        </div>
      </header>
      <article>
        <div dir="ltr" style="text-align: left;" trbidi="on"><div style="text-align: justify;"><span class="Apple-style-span" style="font-size: large;">Two ways to skin a cat</span></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A few months ago, I tried my hand at making a graphic. I picked Paint.net (Gimp just isn't a "together" app for a newb, sorry) and a simple enough project: I would create the title graphic for my yet-to-see-light-of-day&nbsp;personal website exactly the same as <a href="http://www.showoff.io/">this site's</a>. The subdued look and the sunken text jived with my sensibilities and I wanted to learn to create that effect all by myself.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Paint.net has a very active community and soon I found a simple enough guide to do what I wanted. I followed the steps and was able to recreate the graphic - almost. The difference was that the guide assumed a fixed background and I wanted the effect to work regardless of the background color. The only way to do this is to make the background use the "invisible" color - which was helpfully available in another guide. Thus began an long series of minor tweaks to combine the two guides' advice and result in a graphic that looked "just right".</div><div style="text-align: justify;"><br /></div><div style="text-align: left;"><div style="text-align: justify;">Satisfied with my initial success, I tried doing it again with different text; at which point came a larger realization: I couldn't recreate the exact steps that led me to the final graphic! Try as I might (and I did try a lot) the outcome of each experiment turned out to be ever so slightly different from the others - despite following essentially the same "algorithm".</div></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Graphic design (I know this term has a larger meaning, bear with me) essentially follows the <a href="http://en.wikipedia.org/wiki/Painter's_algorithm">Painters Algorithm</a>. Layer after layer of paint (pixels) are placed in an exact order so that the resultant graphic will serve its purpose from exactly one angle - the one that the graphic is intended to be viewed from. True, software allows for easy undo and redo of these layers and the easy (and gratuitous) application of effects, but there's little difference in principle between this activity and hand-drawing.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">More over, the raw material being molded into final shape is nothing bigger than a pixel. Well, maybe groups of pixels via Lassos and Layers, but pixels nonetheless. The basic idea seems to be: corral a bunch of pixels and subject them to an effect. Repeat&nbsp;corralling&nbsp;and effect-subjecting till desired result is attained.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Contrast this with 3D rendering where the raw materials are shapes, their properties (especially texture), the light sources that impinge on them and so forth. The mental model is straightforward because the representation is real-wordly and - this is crucial - a 2D projection of the object(s) can be taken at will to represent any POV. This projection is essentially the same as the Painter's Algorithm - rendering it requires calculating planes (layers) that lay in front of others and therefore don't need to be displayed.<br /><br />Except that we have a computer doing it for us; we don't have to painstakingly figure all that out by hand.</div><div style="text-align: justify;"><br />Reflecting on this in a slightly grander scale led me to think:<br /><br /></div><div style="text-align: justify;"><span class="Apple-style-span" style="font-size: large;">...Are we painting our code or rendering it?</span><br /><br />My team is currently trying to refactor some code. The code is about a page and a half long and was written about a month ago. It has unit, component and integration tests attached to it. Yet the original author (quite a bright chap) is unable to figure his own code out. He knows that it works and knows that it will break unless its written exactly the way it is. Beyond that, however, he's unable to explain why it works the way it does; or - more importantly - explain the logic succinctly such that the "why" could be remembered. If we had to introduce a change into the logic, that would be flagged as a "major enhancement". Here's the other twist: The code is in the critical path of 7-8 business scenarios and therefore has to be tested for all those scenarios ; but being path-agnostic in and of itself, that fact is not readily apparent from looking at the code at all!<br /><br />I begin to wonder therefore: Does the shape of the code reflect the shape of the real world thing it is attempting to represent?<br /><br />Another example: I just finished reading <a href="http://www.threeriversinstitute.org/blog/?p=594">Kent Beck's post on Horizontal and Vertical Refactoring</a>; and what struck me is the recognition of the idea that code could have more dimensions than one.<br /><br />Better tools for a better age<br /><br /><span class="Apple-style-span" style="font-size: large;">... but after a while all is see are blondes and brunettes</span><br /><span class="Apple-style-span" style="background-color: white;"></span><br /><div align="left"><span style="font-family: Arial, Helvetica, Geneva, Swiss, SunSans-Regular;">Neo: Is that...</span></div><div align="left"><span style="font-family: Arial, Helvetica, Geneva, Swiss, SunSans-Regular;">Cypher: The Matrix? Yeah.</span></div><div align="left"><span style="font-family: Arial, Helvetica, Geneva, Swiss, SunSans-Regular;">Neo: Do you always look at it encoded?</span></div><div align="left"><span style="font-family: Arial, Helvetica, Geneva, Swiss, SunSans-Regular;">Cypher: Well you have to. The image translators work for the construct program. But there's way too much information to decode the Matrix. You get used to it. I...I don't even see the code. All I see is blonde, brunette, red-head. Hey, you uh... want a drink?</span></div><div align="left"><span style="font-family: Arial, Helvetica, Geneva, Swiss, SunSans-Regular;"><br /></span><br /><span style="font-family: Arial, Helvetica, Geneva, Swiss, SunSans-Regular;"><br /></span></div><br />(the argument that the expert doesn't need the UI)<br />visual vs higher order<br />- finally circle back to "painting has its place, just not in mainstream sw dev"</div></div>

      </article>
      <small class="is-right">&copy; 2023 Vinod KD </small>
    </body>
</html>
