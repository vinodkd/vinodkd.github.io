<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Jack: some new thoughts, a few iterations</title>
        <meta name="viewport" content="width=device-width, initial-scale=0.8"/>

        <link rel="stylesheet" media="all" type="text/css" href="/css/normalize.css" />
        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">
        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">    
    </head>
    <body class="container">
      <header class="is-left stck-horizontal">
        <h1><a href="/"><img src="/favicon.png"></a>  Jack: some new thoughts, a few iterations</h1>
      </header>
      <article>
        <div id="post" class="post">
    <header class="post-header">
        <span class="post-title">Jack: some new thoughts, a few iterations - ( 27 Oct 2011 )</span>
        
            <span class="post-tag">jack </span>
        
    </header>
    <article class='post-content'>
        <div dir="ltr" style="text-align: left;" trbidi="on">Some strands of thoughts have come together of late as I re-read my posts about Jack, watched Subtext and talked about CodeViz to people. Things congealed into place as I revisited OMeta and decided to give it a shot as a prototyping platform.<br /><div><br /></div><div><b><span class="Apple-style-span" style="font-size: large;">Iteration 0</span></b></div><div>As a precursor to trying OMeta out I listed out the features that Jack was supposed to have based on my posts. Here's what I came up with:</div><div><script src="https://gist.github.com/1319651.js">  </script></div><div>Transforming this to OMeta syntax, here's what I came up with:<br /><script src="https://gist.github.com/1319674.js">  </script>As you can see, some compression has happened from my BNF-ish syntax to the OMeta one. <br /><br /><span class="Apple-style-span" style="font-size: large;"><b>Iteration 1</b></span><br />Pumped by this quick success, I immediately started counting my unhatched chicken. How would people easily share Jack code, I wondered? I'd already thought of YAML as a storage format so, I quickly wrote up the YAML version of the function from above:<br /><br /><script src="https://gist.github.com/1319735.js">  </script></div><br />I also came up with the whole slew of pipelines that would bring Jack (and some part of Fluent) to life:<br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">text syntax &nbsp; --JackTxtParser-------><span class="Apple-style-span" style="white-space: pre;">&nbsp;</span>JackAST</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">JackAST &nbsp; &nbsp; &nbsp; --JackUIRenderer------> JackViewTree</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">JackViewOp &nbsp; &nbsp;--JackUIModifier------> modifiedJackViewTree</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">JackViewTree &nbsp;--JackInterpreter-----> JS Evaluation</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">JackViewTree &nbsp;--JackCompiler--------> JS Source</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">JacViewTree &nbsp; --JackTxtGenerator----> text syntax output</span><br /><div><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-style-span" style="font-family: 'Times New Roman'; font-size: large;"><b>Iteration 2</b></span></span><br />Then reality set in. What are the primitives I'd need to build for this to take off? A reverse read of all jack posts revealed the following set of "things to be built":<br /><br /><br /><ul style="text-align: left;"><li>A primitive conditional</li><li>The ability to make a module out of anything and vice versa</li><ul><li>make module (code list)</li><li>devolve module into codelist(module)</li></ul><li>A way to denote a function as optimized via a Foreign Function Interface (FFI). This could be in the fact language, but this means the fact language and the compiler should talk.This is probably required anyway; the interpreter should be able to query the analyzer for facts' veracity.Note:&nbsp;This facility is like annotations, but doesn't entail arbitrary side effects as the annotation processor allows through arbitrary code running.Each FFI, however, should expose a way to call the underlying optimization, with ways to map values to and forth.</li><li>The ability to refer to any single piece of code: built into the structure already. url tbd</li><li>The ability to refer to any set of code pieces: define a continuous code range, define an arbitrary list of code pieces (is this required)</li><li>The ability to comment on such a set of code pieces: ie attach a comment to a code set. this is somewhat similar to the modularize reqt above</li><li>An FFI to scm tools with the basic functions supported</li><ul><li>check in/out</li><li>commit</li><li>branch</li><li>merge</li><li>snapshot</li></ul><li>A functional version expression</li><li>The ability to represent WIP code</li><li>Most importantly, an interpreter that supports all this</li></ul><br /><div><span class="Apple-style-span" style="font-size: large;"><b>Iteration 3</b></span></div><div>Then I took a step back and looked at the complexity growing. Could there be some abstraction done? Here's the outcome of some furious (re)thinking:</div><div><ul style="text-align: left;"><li>There are nodes</li><li>Nodes have attributes</li><li>Standard attributes are:</li><ul><li>[id] is used to uniquely identify a node. it can be system-generated or user-provided</li><li>[comment] is used to provide a comment about the node.</li><li>[fact] is used to state a fact about the node using FOPL; and is typically used to derive some "higher order knowledge" about the node</li><li>[name] is used to provide a referencible alias for the node.</li><li>[kind] is used to identify the type of node. this may be dynamically assigned to implement duck-typing.</li><li>[context] is used to "run" or execute the node.</li></ul><li>Other attributes can be added at will and used in execution</li><li>A collection of nodes is also a node, and therefore can have the same attributes and be executed similarly.</li><li>Standard nodes are:</li><ul><li>base:</li><ul><li>block<span class="Apple-tab-span" style="white-space: pre;">  </span>: a continuous sequence of nodes to be executed one after the other</li><li>if<span class="Apple-tab-span" style="white-space: pre;">   </span>: a node that conditionally executes one of its child nodes</li><li>define<span class="Apple-tab-span" style="white-space: pre;">  </span>: a node that adds a name to a node</li><li>function&nbsp;: a named block</li><li>module<span class="Apple-tab-span" style="white-space: pre;">  </span>: a collection of functions</li><li>app<span class="Apple-tab-span" style="white-space: pre;"> </span>: a collection of modules</li></ul><li>meta:</li><ul><li>group<span class="Apple-tab-span" style="white-space: pre;">  </span>: a node that groups other nodes (and optionally names)</li><li>split&nbsp;: a node that splits an existing group</li><li>insert<span class="Apple-tab-span" style="white-space: pre;"> </span>: a node that inserts a node at a given point in a collection</li><li>delete<span class="Apple-tab-span" style="white-space: pre;"> </span>: a node that deletes a node from a collection</li></ul><li>versioning:</li><ul><li>checkout<span class="Apple-tab-span" style="white-space: pre;"> </span>: a node that checksout a version of its input node ref from scm</li><li>commit<span class="Apple-tab-span" style="white-space: pre;"> </span>: a node that commits a version of its input node ref to scm</li><li>branch<span class="Apple-tab-span" style="white-space: pre;"> </span>: a node that branches a version of its input node into a new branch</li><li>merge<span class="Apple-tab-span" style="white-space: pre;"> </span>: a node that merges two node refs</li><li>standin<span class="Apple-tab-span" style="white-space: pre;"> </span>: a node that can stand in for any other node. to be used for nodes that dont exist yet&nbsp;</li></ul></ul></ul><div><b><span class="Apple-style-span" style="font-size: large;">Thoughts</span></b></div></div><div>I reached this far and realized something larger abstractions are possible:</div><div><div><ul style="text-align: left;"><li>Jack code could be stored in any data format that can handle trees - backward compatible data format!</li><li>Jack could use any language as host - backward compatible code! Jack is "just another scripting language on top of $my_fav_lang</li></ul><div>So, it sounds like:</div><ul style="text-align: left;"><li>Jack's true role will be to consolidate sequences to specific hosts, create and break interfaces and manage the change that happens - a sort of super shell.</li><li>Ultimately Jack should enable code comprehension and legacy support.</li></ul><div>Maybe Jack should be renamed <b>Glue</b>.</div></div></div><div><br /></div></div></div>

    </article>
</div>

      </article>
      <small class="is-right">&copy; 2023 Vinod KD </small>
    </body>
</html>
